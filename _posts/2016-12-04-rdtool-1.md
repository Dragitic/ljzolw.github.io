---
layout: post
title: "A small niche program in an everchanging world"
date: 2016-12-04
---

### Abstract

Why is the change inevitable? Why does the business change their requirements all the time? Why is it so hard to create a program which Just Works?

This post is an attempt to tell a story of a single program from its start to... well, today. To show how this program is being evaluated and how it is being worked on.

Why? To show how the projects like those are made from the start - by starting small and adapting to constantly changing requirements. To show some tips and tricks I have learnt in the process. To explain the tradeoffs.

Basically, to show _you_ how to start and what you could be dealing with.

### The value of this post to you:

1. If you are someone willing to write the program for yourself / a small group of friends, this whole post is designed for you. You will be able to see: 
    1. why and potentially how will your domain change with time 
    2. why it is not worth it to predict everything 
    3. how not to get paralyzed with 'what to do next' or 'how to start'
    4. how to prioritize what to work on.
    
2.	If you are someone who strives to write perfect code, you will be able to see: 
    1. why it may be impossible to write a perfect program 
    2. why 'perfect' may be a wrong target
    3. why imperfect code is usually good enough under constraints

3.	If you are someone wanting to create something, but not a programmer, you will be able to see:
    1. what types of tradeoffs are you going to deal with
    2. one possible approach to creation which works best with stories, programming and things which are easy to change
    3. but be aware - software, stories... those are very mutable. You can easily change them. Hardware, woodwork... those things are hard to change. They require a different approach.

4. Finally, if you have always wondered how the programs are started and maintained with time:
    1. you will be able to read a semi-detailed story which - I hope - will be entertaining

### Why did I write this post?

I am both a lead programmer of a small program and one of product owners and customers needing the output of that program. This gives me a unique perspective, because I have many roles in the same project.

The program I am working on has had a lot of business requirements changed. Even today, after 2 years since we started I still have no idea how it is going to look like in its final form.

During my work on this program I have seen the business changes influencing the code and the capabilities of the program influencing what the 'business' (that is, us) wanted.

As I am usually interacting with younger developers I have noticed they often have very high expectations on themselves. They expect to do everything 'right' from the start. I want to show them that success very often comes from starting small and flexible and solving one problem at a time - and afterwards deleting things which are obsolete at that point.

Current state of the program (using cloc):

![Current state of the program - cloc metrics: 226 files, 2100 blank lines, 3500 lines of code](/img/161204/161204_rdtool_size.png)

(at one point rdtool had 7000 lines of code, but fortunately I have managed to reduce the amount of code since then)

### Our business? Let's create the world

#### The domain

Imagine you are a member of a group writing a book together. This book is supposed to create a consistent world and a consistent history of the fictional reality. The book is located on a wiki and its structure looks more or less like this:

![Structure of domain: book into chapters, chapters into stories](/img/161204/161204_domain_picture.png)

This type of shared reality creation is a hobby of mine and a group of my friends. We do it under the umbrella name of RiggedDice.

#### The past

In January 2014 our small group started to create a new world. This time we decided that we are going to go more freeform:

![Jumping between the chapters and stories freeform way, ignoring chronology and making chapters on the go](/img/161204/161204_new_approach.png)

In November 2014 we had about 100 characters in 44 stories, split between four chapters. 

And a new type of problem appeared. We started to get lost in our own creation. 

What did a particular character do? What does a particular character know? Did X happen already? Who got Y and what happened to it? 

And so on 25th December 2014 I have created a first commit of an extremely unremarkable program called ‘rdtool’ (short for Rigged Dice Tool). 

This program - at that point written in Ruby - was supposed to spider through the wiki which we all edited, parse all the stories and write down all the links to the stories in which a character was present into that character profile and save all profiles to hard drive:

![rdtool takes stories and profiles from the wiki, combines them and saves them on the hard drive](/img/161204/161204_original_rdtool.png)

That was all I was trying to do.

#### The present

Fast forward to 4th December 2016. 

Our group is not 4 friends anymore. About 15 people have influenced the world we are building since 2014 at this point; some have never interacted with each other in person, but they all influence other people in the same shared reality. The story threads they are creating intermingle with the threads others are creating.

We have about 600 characters in about 200 stories in 12 chapters. The world is still internally consistent (aside occasional sunsetting or editing a story or two).

And the unremarkable program called ‘rdtool’? It is written in Python now and it does a lot of stuff. To be honest, it generates so much things we are migrating from a wiki to a [static site generator](https://www.staticgen.com/about) (most likely [Jekyll](http://jekyllrb.com/) to be precise). 

When we finish - rdtool is going to take the input from Jekyll and generate the output directly into Jekyll. All under git version control system.

![rdtool looks much more complex with Jekyll, but does a lot of powerful things](/img/161204/161204_future_rdtool.png)

#### Why not wiki? What happened?

Without rdtool this shared reality would be extremely hard to be maintained - it would get inconsistent. As the amount of stories grew, we needed more knowledge about the overall reality created by combining those stories. 

This led us to adding new business requirements to rdtool. And... we got to the point wiki itself is not powerful enough. In the beginning, most data was generated by humans; at this point, most data is generated by rdtool.

A typical success story of a niche tool in a niche need.

### Our program? Entangled with our business

#### 0. The beginnings of rdtool

The problem we had in the very beginning was noticed about the Christmas time, 2012. It was more or less like the dialogue below:

* T (my wife): so what happened to Vladimir’s car? Can he get there not alerting anyone?
* Me: I don’t remember; what is special about his car?
* T: it was broken. Then it was rigged with a locator. You don’t remember?
* Me: now I do; thanks for reminding me, this would get QUITE inconsistent.
* T: seriously, we should have people write down those facts directly on the profiles
* Me: but no one wants to do it; it is boring
* T: should be done by machine, then. Automatically.
* Me: okay, we have some evenings… Let me write a prototype
* T: this prototype could take a lot of time
* Me: I will use a dynamic language. Say, Ruby. I heard it’s good in internet stuff.
* T: …
* Me: (smile)

Thing is, it was the first time ever I have worked with any dynamic language. Still, between Christmas and half of January I have managed to get the first iteration to work.

#### 1. First business change

Now... if you know which characters are present in which stories – it is quite easy to go a step beyond. Our wiki pages representing stories already had a section called ‘dramatis personae’:

![dramatis personae has names of the characters present delimited by commas](/img/161204/161204_old_dramatis_personae.png)

It wouldn’t be hard to change it into the format like the one below:

![dramatis personae has names of the characters present delimited by newlines; after a name the comma is a delimiter between person and an action](/img/161204/161204_new_dramatis_personae.png)

Where the first comma is the separator between 'who was present' and 'what did that character do'.

So we have gone back through all the stories, modified the dramatis personae section and during that time I was writing the modification of rdtool.

#### 2. Wait, we can integrate the data!

Some information was also written down on the profiles of particular characters. For example, short descriptions.

_Vladimir Soupmann is very competent as a detective, but lousy in everything else. Tends to have bad luck with his car._

So another expansion was to merge the information which is read from the profiles (those descriptions) with information generated from the stories (the actual history). 

One output file with all the information? Awesome.

#### 3. Okay, so who knows whom?

But then something new appeared. Who knew whom? 

Does Vladimir know Kate? Did Vladimir ever meet Kate and if they did meet – in which story? 

Having already extracted information previously I just had to create a mapping between every character and all other characters remembering a link to the story where they met. The last component was 'how to make tables in the wiki' to put a table 'whom do I know and when did we meet' for every character profile.

Something like this (those were links):

| Relation with whom | Intensity | Which story |
|:-----:|:------------:|:-----------|
| Kate | 3 | story_id_1, story_id_2, story_id_3|
| Ann  | 1 | story_id_1|


#### 4. Where the spiders fear to tread

When we got to about 100 stories, spidering the wiki directly started to become too slow. **Way** too slow. So we needed a new type of data acquisition - something fast. 

Fortunately, the wiki offered a zip file backup. 

I have adapted the reader and parser of the rdtool to read from the zip file. Eventually, web crawling got deleted, as it was not used anymore.

#### 5. Other things?

There were lots of other changes; some were helpful and supported our goal, some were irrelevant (and got reverted / discarded).

Eventually, after working on creating the history records for all locations, we got to a new point.

#### 6. We were saying... wiki?

With the amount of input data and with the scope expansion, every run of the rdtool creates about 800 pages. 

It would be a lot of copying and manually pasting into the wiki. We have looked to see if this wiki presents an API for this, but that particular wiki implementation didn’t have an API we would need (not even in paid version).

To add, my programs aren’t perfect. Sometimes a bug may appear. We have decided that at this point of lifecycle of this shared world it is worth it to use the version control system – make sure even if data gets corrupted by a malfunctioning program, the data is always recoverable _(didn't happen yet, but risk mitigation is something I strongly subscribe to)_.

So what we really need at this point is not a wiki. 

We need something which can be generated mostly by rdtool and edited by humans. We want to have versioned files. We want to automate everything which can be automated – we don’t have time to do things manually.

Thus, a static site generator.

### Why did the requirements change so much?

#### Why? Just - why?

The requirements changed so much, because we did not expect what advantages we can get out of rdtool.

We simply had a particular problem we wanted to solve – a pain point – and solved it. One at a time.

#### Pain point?

A pain point - something is irritating me to the point I am willing write a program to make it go away. Or pay someone to make the problem go away. Same thing.

Business needs don't appear on their own. They usually come from the pain points. Business shift comes from unearthing some other pain points, previously masked by the ones which got fixed. 

In short - what hurts you the most? What hurts you the most **now**? After you soothe the pain point, something else will become a pain point - and not necessarily something you expect.

#### Same story, with pain points

In the very beginning we had the wiki. Everything was centered around that wiki. And it was awesome for that type of usage we needed at that time. Our primary pain point was getting lost between characters and the stories. One story - no way to get lost. 30 stories - lots of opportunities to get lost.

The prototype of rdtool solved that problem, especially after expanding Dramatis Personae section in the stories on wiki. 

Having solved **this** problem we have found **another** problem - something which was not a problem before, because the previous problem was more painful and fundamental.

“In which story did Vladimir meet Kate? Does Vladimir even know Kate?” is really a specialized form of “in which story was Vladimir present?” combined with “in which story was Kate present?”

#### But pain points don't appear on their own!

To get the information “in which stories Vladimir met Kate” I would have to manually search all the stories to find Vladimir and manually search those stories to find Kate if I didn't have rdtool. 

And this is what I have done in the past; when we had 15 stories it was easy. When we have 200 stories it is very hard - the amount of data has made some previous trivial irritations our major pain points.

Also, spidering 20 webpages doesn't take much time. Spidering 500 webpages takes a lot of time. So this kind of appeared on its own, too.

#### Couldn't the business just specify the requirements upfront?

It is possible to specify the requirements if you know what you want to achieve. Then, you aim at that target and try to execute your work as well as you can.

_Not easy, but I know which target to point at ;-)._

![if you know what you want to achieve, the goal is possible to aim at](/img/161204/161204_business_goal_achieve.png)

For example, assume you are trying to build a rocket to the Moon. You have well-defined conditions of success: the rocket has to land there. An impact of the failure is catastrophic - you lost a lot of money and energy. You have only one shot, really.

The more you know about your problem, the better you can tailor your solution to your problem.

The more you know, the more you can design and plan for.

But the program I am writing here is nothing like sending a rocket to the Moon. It is a program supporting a hobby which is a very niche form of entertainment. We don't even KNOW what can help us in this hobby. We have some expectations, but that's all, really.

This program does not exist in set, rigid constraints. It can change into whatever we need it to. The requirements morph into whatever we need at a particular moment. The overall output of the program is far more important than 'getting it right'.

An impact of failure is minimal. 

To add, in a properly bad case I will have to make a heavy refactoring. In the possibly worst case I would have to write it from scratch (very unlikely).

This means that an appropriate corresponding picture looks like this:

_So, which target should I point at?_

![in hobbies, there are many possible goals. Which to aim at?](/img/161204/161204_business_goal_achieve_2.png)

There is no singular goal. There are many goals and things to be improved, some of those mutually exclusive. To add to the confusion - potential goals appear and disappear all the time.

The goal will change with time. Adaptability and ability to change is much more important than hitting a particular goal.

Something like this also happens to a commercial business, too - especially in the exploration phase or the prototype phase.

We have different **types** of problems - and every type of a problem needs a different approach.

#### But... why wasn't a static site generator used from the very beginning?

Our first uses of the wiki come from about 2007. 

Before 2007, we were collaborating using Word / OpenOffice and some voice recordings.

Moving from those to the wiki was not easy. We did not even port the data. It was something _really new_ to us. Something we had to get used to.

So, let's assume **2007** was the moment we were selecting the technology, right?

Github Pages – the 'hosting' similar to the one we will be using for RiggedDice (Gitlab Pages) was created in **December 2008**. _('hosting' is in quotes, because it is more complicated than that)_

In 2008, Jekyll - what we’re going to use for RD in 2017 - was just born. In **October 2008**, to be exact. It did not function as well as it does today. It was much less usable and harder to set up. Basically, it was in prototype stage and prone to constant changes.

If we thought about something like the static site generator, the conversation would go like this:

2008, hypothetical conversation:

* Me: ...so as the opportunities have appeared we should move to a static site generator instead of a wiki.
* BB (one of us): You want to move to a new, unproven hosting...
* Me: Correct.
* BB: With a new, not-completely-stable tool which can die any minute...
* Me: Correct.
* BB: For the benefit of..?
* Me: Err, future. So we don't have to do this in the future.
* T: Before the wiki, largest worlds started shattering at about 50 stories. Why do you expect 200?
* Me: Wiki will hold larger stories.
* T: Riiiight...
* T: And will the static site generator be as easy to use as a wiki?
* Me: Well, no. Not yet. Eventually... yeah, also not likely.
* T: Let's just move to wiki.
* BB: Agreed.
* Me: But... the future... 

The wiki gave us the most possible advantages _at that time_ with the least friction. _Now_, we need something else, because friction of the wiki surpasses the cost of the change.

To make it more fun, those conversations below have actually happened. 

In 2016:

* Dru (friend): What you are doing slowly stops being supported by a wiki
* Me: It is fine, really. It works. It still works.
* Dru: It doesn't. Everything you say proves it doesn't.
* Me: The technical aspect is simply irritating me, but it works.
* Dru: Your hobby frustrates you. This is what you call 'it works'?

And:

* T: You are wasting lots of time uploading it all manually
* Me: I need to make a script uploading things to wiki so I don't have to. But potential data corruption...
* T: You have never corrupted any data.
* Me: Nope, I haven't (remembering some fancy edge case bugs which totally could have corrupted lots of data).
* Me: I need to connect it with some kind of source control system.
* T: Yes, you do. When you have some defenses, you are more creative and have more fun.
* Me: True...

And later:

* BB: Consider moving to some kind of non-wiki pages. Something... more suitable.
* Me: But everyone can edit a wiki easily.
* BB: And how often does that happen, lately? Who edits it mostly?
* Me: Well, me
* BB: Because...?
* Me: I need to upload data from rdtool
* BB: Look into static site generators.
* Me: Why those?
* BB: Because we need something like a CMS, not wiki, at this point.

Thus, the business shift.

#### How to predict the business change, then?

Well, I believe it is impossible.

That is, I believe it is impossible to accurately predict 100% of the features you are going to need from the program you are writing - unless you have a clearly defined goal, impact and the stakes of failure are sufficiently high (like the pacemaker or rocket to the Moon). Then it is worth it to put a lot of energy to make things right from the very start.

The environment changes all the time.

You can predict some things you will need, but with every pain point soothed the business priorities will change - something else will become important. Sometimes unexpectedly.

The business need which finally pushed us to move from the wiki to the static generator was creation of the locations. Imagine – every city, every district, every notable building - they should have their own ‘profiles’ with the information in which stories they took place and which characters were present there (and what happened there, of course).

But this means that every time we make a story we have to generate or re-generate:

* about 10 character profiles
* about 10 location profiles
* 3 master lists (profiles, stories, locations)
* potentially some mechanical stuff, too

This would be a lot of manual wiki insertion. And with moving to a static site generator we also get a version control system - which is not as important if you have 30 stories and you can easily view them to see if everything is okay but becomes quite important when you have 200 stories and when everyone gets invested in the world we are creating. 

But... when rdtool was created, _Locations did not even exist as a section in the wiki_. It is one of those things which were added after a while into every report - like description 'what did the character do' to Dramatis Personae section.

Locations appeared because of rdtool. This program proved it was possible to integrate data from Stories, so it was worth it to go back and create Location map for every Story. To combine all Locations into one map of the world.

#### So... isn't what is described here just called 'Agile'?

Yes, it is. But this is Agile done - I believe - **right**.

If you read the original [Agile Manifesto](http://agilemanifesto.org/) you will see that the focus is on: 

* **humans and their problems** (making pain points go away.)
* delivering **observable impact** (doing things which are visible to humans using our product) 
* **adapting to change** 

...sounds exactly like what I am doing.

What is usually called "Agile" is not what the Manifesto seems to be about. Sadly, very often I see things like the following:

* "we have daily standups, but we don't know why; as we are Agile, we need them."
* "we can select tasks from the board, but there is nobody from the business to consult."
* "we are so Agile we implemented the whole Agile process! No deviations ever!"

Another link supporting my position is [this one](http://10clouds.com/blog/whats-agile-development/). 

To quote the key points: 

* "It’s not the methods that are agile. It’s the people."
* "To be agile is to move quickly, in changing circumstances, and with high efficiency"
* "Agility as a part of a strategy means two things to me: First: be reasonable, not radical. Second: iterate."
* "Methodology implies replicability, predictability, and generalization. That’s the worst definition of agility I could ever think of"

#### Ok, so does that mean that Agile should always be used?

Nope.

Agile is a tool. Nothing more. 

I would definitely not apply Agile Manifesto in a team consisting of very inexperienced programmers, for example. 

Those inexperienced programmers I met usually needed more guidance and simply had to learn too much in the same time; the freedom paralyzed them instead of empowering them. They needed more rigid, more formulaic structure.

#### But why is Agile a tool? Isn't it a mindset?

Everything - processes, programming languages, team composition, infrastructure... - **everything** - is a tool. 

[We use those tools to **help** other people do awesome things.](http://edw519.posthaven.com/who-are-the-real-heroes-of-programming)

I believe that as engineers (software engineers, in this case) we are in the business of solving problems, not writing code. 

Thus, it is our responsibility to choose the best tools for the particular job we are dealing with.

So, like with most cases, context matters.

#### But does the Agile...

Please - I am not an expert on Agile. This article is not about Agile. If you want to read more about Agile, there are wiser and more knowledgeable people on the internet than me.

Let me return to the story :-).

### Condemning failure, seeking perfection

#### Wow, so rdtool is, like, THE perfect program on the internet?

Let me share my Dark Secret with you...

Internally, rdtool operates on this (syntax of this particular wiki):

    +++ This is a header H3

While most static sites generators would write the same header like this (markdown):

    ### This is a header H3

It looks even worse for links: 

    [[[ link-target | Link name ]]]

versus
    
    [Link name](link-target)
    
anyway, because of a syntax change a major internal refactoring of rdtool will be needed. 

At this moment it operates on strings internally and I need to change it into something more flexible to make it work.

#### What kind of a fool writes like THAT? I thought you were the chosen one...

I know, right? A program like this which operates internally on formatted strings? Instead of proper domain objects? How much of a fool have I been?! It was obvious I would have to create a proper structure eventually!

...the key component of the above is "eventually", of course.

Really, flat strings in wiki format were never a good idea. This is easy to predict to anyone with experience. So why did I write it this way?

_Because it is always easy (even if irritating) to refactor from something like flat strings, while it may be quite hard to refactor between different types of domain objects._

But I am getting ahead of myself here; let me start from the business angle. 

#### The business angle - should rdtool even exist?

[Paul Graham wrote an essay on startups](http://www.paulgraham.com/13sentences.html) which perfectly captures my reasoning here. The key part in terms of this post: idea evolves, you don't know what your users will love, so iterate and work with prototypes until you have something which works. Then focus on doing that well.

There was that dialogue between me and my wife in the Christmas 2014 which led to the first commit. 

At that point I expected the program to do more or less something like this:

![rdtool takes stories and profiles from the wiki, combines them and saves them on the hard drive](/img/161204/161204_original_rdtool.png)

When we look at this picture again, we see there are really three main actions of the program - all three need to succeed or the program will not work:

1. spider the wiki, parse the websites and extract the Stories
2. combine parts of Stories into some kind of result
3. save that result on the hard drive

What can go wrong with the above? Remember I have never dealt with the web before and I am working in a language I have never seen.

1. the most difficult part of the program is spidering the wiki and parsing websites
2. the most difficult part of the program is combining parts of Stories
3. the most difficult part of the program is storing things on the hard drive

Well, let's look at those.

* (3) is definitely a false sentence. There are simple tutorials on file IO in every language.
* (2) is unlikely; substrings and string manipulation is tedious, but not difficult.
* (1) is a potential problem. I have never done that.

So the most attention should be brought to (1), as this is the highest risk component of the program. If (1) fails, whole program fails. Risk management.

What solves this kind of problem is [prototyping](http://gamesfromwithin.com/prototyping-for-fun-and-profit). The linked article explains this concept very well; key points:

* a prototype has a single goal, a single very specific question to answer. 
* a prototype is to answer that question as cheaply and as fast as possible
* a prototype is used to reduce the risk of having the answer to that question in form of: 'no'
* a prototype is used to find and calibrate a potential architecture of the program
* a prototype is usually discarded after it is done

In case of the prototype of rdtool:

* The question was 'can **this type of program** help us manage the complexity of a shared world'?
* Implies: I do not need to have the 'program' itself, but its output.
* Implies: I need to make a prototype of (1, 2, 3). Not perfect, but has to work.
* Implies: rdtool is a **tool** to manage the shared reality, not a goal in itself.
* Implies: if the output of rdtool doesn't help us, this program is not necessary.
* Implies: I have to waste the least possible time on that prototype.

So the prototype was written quickly and the output information helped us manage the stories - therefore validating the existence of rdtool. 

I could write it again, but now I had several advantages:

* The prototype helped me create a first skeleton of the architecture of 'proper' rdtool.
* The prototype proved that I am able to spider the wiki and generate some results.
* The prototype showed me how to go and what to focus on while writing rdtool.

In effect, this meant that the risk that the project is pointless has been nullified; now it was the long but not-too-difficult job of formatting, edge case analysis etc.

As a contrast: imagine what would happen if I started from writing a program with: 

* perfect design and a perfect structure 
* 100% test coverage (while learning how to make tests in Ruby, of course) 
* and I would have first results about March? 

We (me and my wife) would probably decide that it is not worth it to write this program. 100-150 hours to have first (even if perfect) results? 

We do not have infinite time and every evening we can have together is precious. 

#### But... this is a hobby! rdtool was inevitable!

Nothing is inevitable. We could still create realities together. An alternative to rdtool was not 'stop creating complex realities'. We would simply make two rules when creating stories: 

* a single character can appear only in one chapter
* a chapter cannot have more than 26 stories

This would be a different way to solve the problem of getting lost. This would also allow us to create a consistent and interesting reality - by applying constraints.

_This would also work._

The resulting stories would be different, they would be less entangled and less intricate, but it would be an acceptable tradeoff.

_(incidentally, before rdtool appread, all the realities we have made became inconsistent about 60-100 stories)_

There are always some alternatives. And this leads us neatly to the importance of estimation.

#### Estimation is a tool to choose which way to go

At the point rdtool was started we have already noticed that people are unlikely to do boring things, even if those are helpful (like complete the information in the character profiles). 

This meant that the first inconsistencies would start to appear soon. Thus, we had two ways to go:

* we change the rules 
* we write a program

Changing the rules is an obvious cost in terms of story generation. It can be done any moment. 

In 2014 we were creating about 4 stories per month _(45 in 2014, 59 in 2015, 67+ in 2016; rdtool has vastly improved our velocity)_. 

This gave us about three months of leeway with the base velocity of 2014 before we start having major problems.

This meant we had three months to decide how to go forward. This meant I had about a month to write something usable so we can evaluate how much that helps us.

Thing is, if you remember that rdtool started from 3 main components, it was easy to estimate how much time I would need:

_unknown time for web spidering (about 2 weeks tops?) and **much** less than a week for the other parts just to make it somewhat work - I do not have 40 hours per week for this ;-)._

The key result - I would need less than a month. And I need to make web spidering in 2 weeks time. If I can't do it in that time, abort and change the approach.

So we decided not to change the rules and try the programming approach first. In case a bug or two would appear for some edge cases, we could have simply generated stories without those characters until the bugs were corrected (and this, of course, has happened).

Because strings were never a key problem of rdtool, I have simply decided to use preformatted strings as an internal structure. I can always refactor the code as needed. Real problems were elsewhere.

#### But if you did it right you wouldn't have to refactor!

[If I did it 'right' I would have never started.](https://8thlight.com/blog/nick-dyer/2016/11/17/dont-make-it-perfect.html)
 
The program is just a tool. _What matters is if the program fulfills its purpose_ - is the time investment in writing the program worth it to actually write that program?

Don't get me wrong - I actually like programming. But my programming must have a **purpose**.

Currently, rdtool is saving us about 1-3 hours per 5 hours of story creation and it expanded what we can do with our realities. 

But in the beginning it saved us about 10 minutes per 5 hours. When I started writing rdtool we had no idea it could become so useful. 

Would you invest 200 hours into a program saving _2 hours_ per 5 hours of creation and expanding our capabilities? I would. 

Would you invest 200 hours into a program saving _10 minutes per 5 hours_ of creation and doing nothing else? I wouldn't.

Fun thing - eventually, we may decide to stop developing rdtool at all. It will happen when we stop getting advantages from expanding it. 

There was a time when we stopped development for four months, because the pain points which were left were less painful than the lack of our time together.

#### The technical angle - domain modeling

[Eric Evans wrote](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215) that a well modeled program should have the code closely corresponding to the business domain of the problem. But how do you know what the domain is? You ask a domain expert (person on the business side doing stuff the programmers are working on). Who is the business expert in this domain here? 

Well... basically, us. 

Yet our pain points were shifting all the time, as the currently most painful point moved all the time.

I mean, think about it. We don't even know what our problem is - it changes all the time, because the environment changes.

#### So what can we do about THAT?

This problem is known as a [cone of uncertainty](http://www.construx.com/Thought_Leadership/Books/The_Cone_of_Uncertainty/):

What we really know about the program we are working on _and_ about the domain of that program:

* We know the _least_ when we _start_ working on them.
* We know the _most_ when we _finish_ working on them.

This means that in an ideal world we would design the program more or less when we finish working on it to get it right.

...this does sound somewhat impossible, though.

I prefer to defer the decision-making time as much as possible, accepting the imperfection - making the least assumptions and _writing the code which is easiest to change_.

In other words - I do not try to write the _best possible code_ for the program which I am writing today. I try to write the _code which will be easy to change_ for the program I am writing today, because I do not know what type of program I will be writing tomorrow.

This is the code from rdtool in March 2016 in Ruby:

![Combine into profile code snippet in Ruby, March 2016](/img/161204/ruby_from_1603.png)

And this is the code from rdtool in Dec 2016 in Python:

![Combine into profile code snippet in Python, December 2016](/img/161204/python_from_1612.png)

As you can see, there are some changes (profile_masterlist is needed, cosmetics differ), but the overall code is very similar.

How did that happen?

This part of the code corresponds to the (simplified) business action:

![Diagram of the business action 'combine into profile'](/img/161204/combine_into_profiles.png)

This is as high level code as I am able to write here. Let's suppose, I will modify the business action:

![Diagram of the business action 'combine into profile'](/img/161204/combine_into_profiles_modified.png)

Thing is, the code **will not change at all** at this level.

The function _create_complete_collection_ already takes all generated profile components. Whatever is inside. What will change is one of the functions called much deeper in the code, when the actual 'generated profile' will be created.

And even then - only a single parameter will be added to a factory function.

To compare, creation of the complete profile in Ruby, March 2016:

![Create complete character in Ruby, March 2016](/img/161204/ruby_create_character_1603.png)

and in Python, December 2016:

![Create complete character in Python, December 2016](/img/161204/python_create_character_1612.png)

They have only one difference - Python code needs profile_masterlist.

With time, if you follow the domain, the architecture will start emerging on its own. With time, you will understand your problem - your code structure - better and better. The cone of uncertainty will get narrower and you will be able to crystallize your structure into something which will be easy to adapt and change.

This is the balance between the [Emergent and Intentional architecture](https://mikemacd.wordpress.com/2013/02/04/intentional-vs-emergent-architecture/):

* "There’s a scale with intentional architecture on one side and emergent architecture on the other."
* "The purpose of any architecture is to shape the solution and address technical risks."
* "If you’ve got a well known technology and problem domain you can get away with emergent architecture"
* "If you have a totally unknown technology and problem domain it can be very effective to evolve towards a solution"

#### Does that mean it is never worth it to work with architecture and design things?

Never say never. Those are tools - and very useful ones.

Architecture, design, modeling... those are really difficult problems in programming. If we don't do them, we simply get a horrible technical debt - or waste a lot of time on refactoring whole application. As I often say, context matters.

This story is a story of a small group of friends and of one niche tool. This is a hobby program with low stakes and very high uncertainty about the domain.

In a larger team, having better defined problem or when more things are at stake I would definitely sit down and start making some of those design decisions intentionally, leaving some areas for emergent evolution. I would definitely try to define higher level intentionally, predict typical scenarios, assess the risk and let the lower level define itself emergently. 

Truth be told, I always somewhat do this by writing code the way I do - I write code, right click and 'generate function', top-to-down. I tend to model the communication in my programs on paper when I have doubts how to proceed. I tend to mirror the domain as much as I understand it.

The program actually lives or dies by its structure much more often than one would expect. Remember, that the code structure and the code itself are really the UI for the programmer.

This stuff is really important.

#### How to write the code which looks like this, by the way?

Say, let's look at this business action again:

![Diagram of the business action 'combine into profile'](/img/161204/combine_into_profiles.png)

What happens in this business action, in steps?

1. Get all the Stories from the data source (zip backup of wiki).
2. Get all information about characters from data source (zip backup)
3. Generate all information about all the Characters from the Stories 
4. For each character, combine information from (2) and (3)
5. Save it to hard drive

And now look at the source code again. Focus on lines 20, 23, 26, 28, 29:

![Combine into profile code snippet in Python, December 2016](/img/161204/python_from_1612.png)

Do you see it?

Once you see how this simple algorithm above corresponds to the written code you will see that this code just **had** to look more or less like this.

#### Why is it worth it to mirror the domain in code, by the way?

If a program closely resembles the domain, every shift in the domain is relatively easy to be mirrored in the program. There are less dirty hacks in the code. This is the major advantage of domain modeling – even if the change is time-consuming, it will not break my program.

I mean, you have seen it already. Changes will happen on 'lower' levels. 'Higher' levels will not change.

This concept is the combination of [encapsulation](https://en.wikipedia.org/wiki/Encapsulation_%28computer_programming%29) (keep things in boxes so the changes in domain will not spill out of those boxes) and [abstraction](https://en.wikipedia.org/wiki/Abstraction_%28software_engineering%29) (make things as general and as close to domain as sensible).

#### But the formatted strings...

Those strings simply did not require any changes before. They just worked and did their job. On top of that I did not know _how_ is the domain going to shift.

Now that there is a business need, there exists a reason to actually tackle this problem and do it _right_ (for a given definition of right, of course).

Imagine I have made a wrong decision about the domain - this would influence the high level interfaces through which I communicate my intention. This would be much harder to change than simple strings with formatting attached.

#### But the domain cannot shift THAT much

When I started working with dramatis personae parsing and integrating in rdtool I thought my domain looks like this:

![Vision of the domain, March 2015](/img/161204/old_domain.png)

Right now, in my mind it looks more or less like this:

![Vision of the domain, December 2016](/img/161204/new_domain.png)

Sure, not everything here is implemented but is just a matter of time. I know exactly what to implement in what way; I just have to work a bit on that.

#### But if you know what you are going to implement, just prepare for it

I would have never predicted that the small prototype I have started writing two years ago would expand to something like what we have today. And we have a lot of awesome ideas how to go forward with the program, and probably 80% of those ideas will never happen. 

Some things may even get deleted - like spidering, which was cut in 2015.

If I tried to create todays program instead of a small prototype which helps with the pain points I used to have, I would have written nothing. At that time I didn’t know Ruby, I didn’t know Python and I had a vague understanding of the problem I was trying to tackle. 

If I tried to write a perfect program, I would have created wrong domain objects. I would have crystallized a wrong domain. I would make a program much harder to refactor than what I have today. 

In the long run, that would be a mistake. But in the short run, I would have some nice code I could show on presentations ;-).

### Conclusions

#### 0. Context of those conclusions

If you jumped to those conclusions from the beginning to see if it is worth it to read this short story, be aware of the following:

* This post is really a story about a small, niche tool written in very casual environment.
* Those conclusions are based around the idea of a 'hobby project'. You know - writing things for yourself and a group of friends. Not around writing enterprise architecture which loses millions of dollars per an hour of downtime.
* Those conclusions may be hard to understand without reading the whole article.

And now, being sufficiently demotivated, feel free to read further :-).

#### 1. Context matters  
Every decision we make, be it on a business or a technical level will have an impact on the users and on the ecosystem we are influencing. The fact that one team made a decision which had a positive impact doesn’t mean that another team making the same decision will have a positive impact as well. 

Context of the decision – expected gain, cost, risk, impact, what people are involved, what resources do we have at our disposal – this really makes a difference.

**Example 1**:
The approach presented here works for the team of 1-3 programmers having very high autonomy and understanding the business impact of their work. It won’t work for a large team under tight control of the manager who receives the list of tasks with priorities from the people above.

**Example 2**:
If I had 50 users of rdtool, some of them completely non-technical, the move from a wiki to a static site generator would be a wrong move. As it stands, all current users of our ecosystem are technical enough to be able to commit a file in git. 

If (when?) this changes and becomes a pain point, an auxiliary program will probably have to be written which will do it for them. Or I will search for a nice-looking git client which pretends it is not git.

#### 2. Everything is really connected

The business strongly influences the program. The program enables the business to do more things, awesome things. The business wants the program to change.

Some problems can be resolved either in code (critical data in rdtool -> better tests) or in environment (critical data in rdtool -> source control versioning). Sometimes the program is not even needed - it may be enough to change the rules.

As there are really many dimensions to every problem we are working on it is very easy to get lost. How not to get lost? One has to remember, that...

#### 3. Every program exists for a reason 

rdtool is not being written because I feel like writing it. It is being written because it solves a major problem our group has with our hobby. It exists for a purpose. It solves some pain points. It saves us time.

We - software engineers - are really catalysts for other people. We are making other people more awesome. We are building their tools - software - so they can make the world a better place.

If the program does not solve any pain points, if it does not enable anyone to do anything better, why write it? Where do you find the motivation to work on it? How do you know it is time to stop? How do you know how to expand it?

#### 4. Business requirements will shift

Assuming every program is written because it solves some kind of problem, the business will find another problem which is possible to be solved by this program. 

To put it bluntly – if you break your leg and if you have a toothache in the same time, you complain about your leg and get it fixed first. Afterwards you go take care of your tooth. Or opposite, really.

Exactly the same mechanism applies to programming. Every time something is corrected for the business, the business finds something else which hurts them.

And this is a good thing, because our work has an impact. But it requires changing the approach to programming as well.

Nothing is set in stone, ever.

#### 5. Design is fluid, code is fluid

All the points above lead to this one – because the context changes, program exists for a reason and business requirements shift we often cannot really predict what the program is supposed to look like when we start working on it.

There are many important decisions to be made between Intentional architecture and Emergent architecture. Between things which have to be modeled and things we hope to crystalize as they appear on their own. And here the context matters the most. Risk, impact, predicted vector of change, how well we understand the domain, how well the business understands the domain...

We can design a perfect program for the current set of requirements but it will not be perfect for the set of requirements in two years.

For example, currently rdtool does not spider the web anymore. This functionality got deleted.

In terms of hobby projects - I believe it may be better to create a mutable design which is easy to change and expand. I believe that creating a perfect solution for _today_ may not be the best use of energy if we get the domain wrong.

#### 6. Imperfect today is better than perfect tomorrow

I think this post is the best proof of this conclusion. It is not perfect. Making it perfect would require about 20 more hours.

In the same time, those 20 hours can be spent on rdtool or with my wife ;-).

There are many definitions of perfection: perfect code, perfect quality, perfect readability, does perfectly what it is supposed to. 

Optimizing towards a particular type of perfection is a trade-off, and there is also a [Pareto Principle](https://en.wikipedia.org/wiki/Pareto_principle) (80-20) which says in this context, more or less, that final 20% of work will take 80% of time - but also, that first 80% of impact takes only 20% of time (so-called [Happy Path](https://en.wikipedia.org/wiki/Happy_path)).

Of course, one cannot leave the state of work on a Happy Path alone. But Pareto Principle is an iterative principle:

* First 80%, second 80%, third 80%... this is 99% done already.
* Implies: next 20% will take... lots of time.

Having limited time and having everything mutable and subject to change I usually try working with things which are easy to change and which have the best gain-to-cost.

When the code itself becomes a pain point, however, it is not 'good enough' anymore. And because of the importance of rdtool it is very often the highest possible priority.

Still, I don't get it to 'perfect level'. Only to 'good enough'. No pain -> no problem.

#### 7. Sometimes the program is simply done  

Because every program is written to do something, there will come a time when the program is done. 'Done' means that putting more energy into the program does not give you enough gain to be worth it. If the pain points are not strong enough and if there is no reason to continue working on the program, simply use it and don't work on it anymore. 

Congratulations.