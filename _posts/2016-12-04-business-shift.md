---
layout: post
title: "Business shift"
date: 2016-12-04
---

### The value of this post to you:

1. If you are someone willing to write the program for yourself / a small group of friends, this whole post is designed for you. You will be able to see: 
    1. why and how will your domain change with time 
    2. why it is not worth it to predict everything 
    3. how not to get paralyzed with "what do do next"
    4. how to prioritize what to work on.

2.	If you are a programmer working in a larger company, you can see: 
    1. why the business is not stupid yet makes some strange choices
    2. how deeply the business and programming are interlinked
    3. an approach to programming which works for small autonomous teams, but is usually less appropriate in the context of programming in a large team. 

3.	If you are someone who strives to write perfect code, you will be able to see: 
    1. why it may be impossible to write a perfect program 
    2. why 'perfect' may be a wrong target
    3. why imperfect code is usually good enough under constraints

4.	If you are someone from the business side, you can see: 
    1. prioritizing of highest value (impact on our group) at the lowest cost (time)
    2. how every change in the business influences the code considerably
    3. why it is worth it to explain your business to programmers instead of giving them tasks
    4. why everything slows down with time and gets more expensive

### Creation of the world

##### The domain

Imagine you are a member of a group writing a book together. This book is supposed to create a consistent world and a consistent history of the fictional reality. Example: "Chronicles of the Omega", sci-fi.

This book is split into different chapters. Every chapter is a slice of time centered around a particular topic or story thread (example: "Omega Awakens" or "Darkness of Metropolis"). 

And every chapter is made of individual stories which are actual records of what happened (example: "The lost key", then "Secret chamber" and finally "Escape!" as three short stories in "Omega Awakens").

Shared reality creation. This is a hobby of mine and a group of my friends. We do it under the umbrella name of RiggedDice.

##### The past

In January 2014 our small group started to create a new world. This time we decided that we are going to generate chapters and stories when we felt like it. We can inject a story in the past, we can go on a tangent and add even more characters in the story. In short, instead of writing things linearly we can write them like we want to, creating and changing things on the fly. What can go wrong?

In November 2014 we had about 100 characters in 44 stories, split between four chapters. And a new type of problem appeared, one greatly magnified by the fact we can create stories in different points of time. We started to get lost in our own creation. What did a particular character do? What does a particular character know? Did X happen already? Who got Y and what happened to it? 

And so on 25th December 2014 I have created a first commit of an extremely unremarkable program called ‘rdtool’ (short for Rigged Dice Tool). This program - written in Ruby - was supposed to spider through the wiki which we all edited, parse all the stories and write down into every character profile all the links to the stories in which that character was present.

That was all I was trying to do.

##### The present

Fast forward to 4th December 2016. We have about 600 characters in about 200 stories in 12 chapters. The humble program called ‘rdtool’ is written in Python now and we are migrating from the wiki to a [static site generator](https://www.staticgen.com/about) (probably Jekyll to be precise) and when we finish - the program is going to take the input from Jekyll and generate the output directly into Jekyll. All under git version control system.

Our group is not 4 friends anymore. About 15 people have influenced the world we are building since 2014 at this point; some have never interacted with each other in person, but they all interact in the same shared reality and the story threads they are creating influence other people.

##### The lesson?

The wiki stopped being powerful enough for our needs at this point. Most data is generated by rdtool, not by humans. 

The existence of rdtool made it possible for us to expand the scope of what we do and of the rdtool itself. This shared fictional world would not be possible to be created as it is without this program. 

A typical success story of a niche tool in a niche need.

This also gives me a unique perspective. I am both a lead programmer of rdtool and one of product owners and customers needing rdtool and its output for the shared world creation.

During my work on this program I have seen the business changes influencing the code and the capabilities of the rdtool influencing what the 'business' (that is, us) wanted. And this is what I would like to share with you in this post. The origin of the business shift, why business change is awesome and how can a small and empowered team adapt to the need of the business.

### The business shift

##### 0. The beginnings of rdtool

The problem we had in the very beginning was noticed about the Christmas time. It was more or less like the dialogue below:

* T (my wife): so what happened to Vladimir’s car? Can he get there not alerting anyone?
* Me: I don’t remember; what is special about his car?
* T: it was trashed. Then it was rigged with a bug. You don’t remember?
* Me: now I do; thanks for reminding me, this would require some editing afterwards if I forgot.
* T: seriously, we should have people write down those facts directly on the profiles
* Me: but no one wants to do it; it is boring
* T: should be done by machine, then. Automatically.
* Me: okay, we have some evenings… Let me write a prototype
* T: this prototype could take a lot of time
* Me: I will use a dynamic language. Say, Ruby. I heard it’s good in internet stuff.
* T: …
* Me: (smile)

Thing is, it was the first time ever I have worked with any dynamic language. Still, between Christmas and half of January I have managed to get the first iteration to work.

##### 1. First business change

Now… if you know which characters are present in which stories – it is quite easy to go a step beyond. Our wiki pages representing stories already had a section called ‘dramatis personae’. That is where the 'who was present' was present. 

_Vladimir Zupaczka_

It wouldn’t be hard to change it into the format like the one below:

_Vladimir Zupaczka, who had his car bugged by Millennium and who led M. to the Hideout_

Where the first comma is the separator between 'who was present' and 'what did that character do'.

So we have gone back through all the stories, modified the dramatis personae section and during that time I was writing the modification of rdtool.

##### 2. Wait, we can integrate the data!

Some information was also written down on the profiles of particular characters. For example, short descriptions.

_Vladimir Zupaczka is very competent as a detective, but lousy in everything else. Tends to have bad luck with his car._

So another expansion was to merge the information which is read from the profiles (those descriptions) with information generated from the stories (the actual history). 

One output file with all the information? Awesome.

##### 3. Okay, so who knows whom?

But then something new appeared. Who knew whom? 

Does Vladimir know Kate? Did Vladimir ever meet Kate and if they did meet – in which story? 

Having already extracted information previously I just had to create a mapping between every character and all other characters remembering a link to the story where they met. The last component was 'how to make tables in the wiki' to put a table 'whom do I know and when did we meet' for every character profile.

Something like this (those were links):

| Relation with whom | Intensity | Which story |
|:-----:|:------------:|:-----------|
| Kate | 3 | story_id_1, story_id_2, story_id_3|
| Ann  | 1 | story_id_1|


##### 4. Where the spiders fear to tread

When we got to about 100 stories, spidering the wiki directly started to become too slow. **Way** too slow. So a new type of data acquisition was needed - we have found that the wiki offered a zip file backup. I have adapted the reader and parser of the rdtool and the life went on.

There were far more changes than those, but I think you see what is happening here.

##### 5. We were saying... wiki?

The final interesting change I wanted to show you – with the amount of input data and with the scope expansion, every run of the rdtool creates about 800 pages. It would be a lot of copying and manually pasting into the wiki. We have looked to see if wiki presents an API for this, but that particular hosting didn’t have an API we would need. 

To add, my programs aren’t perfect. Sometimes a bug may appear. We have decided that at this point of life of this shared world it is worth it to use the version control system – make sure even if data gets corrupted by a malfunctioning program, the data is always recoverable _(didn't happen yet, but risk mitigation is something I strongly subscribe to)_.

So what we really need is not a wiki. We need something which can be generated by rdtool and edited by humans. We want to have versioned files. We want to automate everything which can be automated – we don’t have time to do things manually.

The only problem: internally, rdtool operates on this (syntax of this particular wiki):

    +++ This is a header H3

While most static sites generators would write the same header like this:

    ### This is a header H3

It looks even worse for links; anyway, a major internal refactoring of rdtool will be needed. At this moment it operates on strings internally and I need to change it into something more flexible to make the shift work.

We will get to the 'operates on strings internally' soon. For now, let's look at those business shifts.

### Business shift and pain points

##### Pain points?

A pain point - something is irritating me to the point I am willing to pay or write a program to make it go away.

Business needs results from the pain points. Business shift comes from unearthing some other pain points, previously masked by the ones which got fixed. 

In short - what hurts you the most? What hurts you the most **now**? After you soothe the pain point, something else will become a pain point - and not necessarily something you expect.

##### Same story, with pain points

In the very beginning we had the wiki. Everything was centered around that wiki. And it was awesome for that type of usage we needed at that time. Our primary pain point was getting lost between characters and the stories. One story - no way to get lost. 30 stories - lots of opportunities to get lost.

The prototype of rdtool solved that problem, especially after expanding dramatis personae section in the stories on wiki. 

Having solved **this** problem we have found **another** problem - something which was not a problem before, because the previous problem was more painful and fundamental.

“In which story did Vladimir meet Kate? Does Vladimir even know Kate?” is really a specialized form of “in which story was Vladimir present?” combined with “in which story was Kate present?”

##### But pain points don't appear on their own!

To get the information “in which stories Vladimir met Kate” I would have to manually search stories to find Vladimir and manually search stories to find Kate if I didn't have rdtool. 

And this is what I have done in the past; when we had 15 stories it was easy. When we have 200 stories it is very hard - the amount of data has made some previous trivial irritations our major pain points.

Also, spidering 20 webpages doesn't take much time. Spidering 500 webpages takes a lot of time. So this kind of appeared on its own, too.

##### How to predict the business change, then?

I believe it is impossible to accurately predict 100% of the functionalities you are going to need from the program you are writing. You can predict some things you will need, but with every pain point soothed the business priorities will change - something else will become important. Sometimes unexpectedly.

The business need which finally pushed us to move from the wiki to the static generator was creation of the locations. Imagine – every city, every district, every notable building - they should have their own ‘profiles’ with the information in which stories they took place and which characters were present there (and what happened there, of course).

But this means that every time we make a story we have to generate or re-generate:

* about 10 character profiles
* about 10 location profiles
* 3 master lists (profiles, stories, locations)
* potentially some mechanical stuff, too

This would be a lot of manual wiki insertion. And with moving to a static site generator we also get a version control system - which is not as important if you have 30 stories and you can easily view them to see if everything is okay but becomes quite important when you have 200 stories and when everyone gets invested in the world we are creating. 

As a bonus, we won’t have some limitations which were present in the wiki and our creation will be under our control; if the git hosting fails, there are other git hostings. If the wiki fails, we have the data which are incompatible with any other wiki engine. And we have them in a zip file with a flat internal structure.

### Condemning failure, seeking perfection

##### Remember those strings from earlier section?

Imagine – a program like this operates internally on formatted strings instead of proper domain objects. How much of a fool have I been? It was obvious I would have to create a proper structure eventually!

Flat strings in wiki format were never a good idea. So why did I write it this way? There are two different angles to my decision - business and technical.

##### The business angle - prototyping 

[Paul Graham wrote an essay on startups](http://www.paulgraham.com/13sentences.html) which perfectly captures my reasoning here. The key part in terms of this post: idea evolves, you don't know what your users will love, so iterate and work with prototypes until you have something which works. Then focus on doing that well.

There was that dialogue between me and my wife in the Christmas 2014. Before January 2015 I could prove that I am able to spider the wiki and generate some results. This meant that the risk that the project is impossible has been nullified; now it was the long but not-too-difficult job of formatting, edge case analysis etc.

Imagine what would happen if I started to write a program with a perfect structure, 100% test coverage (learning how to make tests in Ruby, of course) and I would have first results about March? We would probably decide that it is not worth it to write that program. 100-200 hours to have first (even if perfect) results? We do not have infinite time and every evening we can have together is precious. 

##### But... this is a hobby! rdtool was inevitable!

Nothing is inevitable. We could still create realities together. An alternative to rdtool was not 'stop creating complex realities'. We would simply make two rules when creating stories: 

* a character can appear only in one chapter
* a chapter cannot have more than 26 stories

This would also solve the problem of getting lost. This would also allow us to create a consistent and interesting reality. This would solve this problem by applying constraints.

_This would also work._

The resulting stories would be different, they would be less fun and less intricate, but it would be an acceptable tradeoff.

_(incidentally, before rdtool appread, all the realities we have made became inconsistent about 60-100 stories; but we were younger, too)_

There are always some alternatives. And this leads us neatly to the importance of estimation.

##### Estimation to choose which way to go

At the point rdtool was started we knew already that people will not do boring things (like complete the information they do not need in the character profiles). This meant we are on the brink of inconsistencies. We have two ways to go:

* do we change the rules 
* do we write a program

Changing the rules is an obvious cost in terms of story generation. It can be done any moment. In 2014 we were creating about 4 stories per month _(45 in 2014, 59 in 2015, 67+ in 2016; rdtool has vastly improved our velocity)_. This gave us about three months of leeway.

This meant we had 3 months to decide how to go forward. This meant I had about a month to write something usable. 

A dirty prototype it was ;-).

Thing is, after I wrote first components of rdtool it was easy to estimate how much time I need to solve that single problem. Not more than a month. So we decided to not change the rules and try the programming approach. In case a bug or two would appear for some edge cases, we can simply generate stories without those characters until I solve the bugs in code. Fortunately, this did not happen.

Imagine what would happen if I tried to create a perfect internal structure for rdtool. At that point I had no idea what the perfect internal structure even is. I had no idea we would ever think of migrating from the wiki. So... formatted strings it was - I can always refactor the code if needed.

##### But if you did it right you wouldn't have to refactor!

If I did it 'right' I would have never started.
 
The program is just a tool. What matters is if the program progresses our goals - is the time investment in writing the program worth it to actually write that program?

Don't get me wrong - I actually like programming. But my programming must have a **purpose**.

Currently, rdtool is saving us about 1-3 hours per 5 hours of story creation. But in the beginning it saved us about 10 minutes per 5 hours. When I started writing rdtool I had no idea it would become so useful. Would you invest 200h into a program saving 2 hours per 5 hours of creation? I would. Would you invest 200 hours into a program saving 10 minutes per 5 hours? I wouldn't.

Eventually, we may decide to stop developing rdtool. It will happen when we stop getting advantages from expanding it. There was a time when we stopped development for four months, because there was no particular pain point. Afterwards several interesting things were added and rdtool required some expansion again.

##### The technical angle - domain modeling

[Eric Evans wrote](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215) that a well modeled program should have code closely corresponding to a business domain of the problem. But how do you know what the domain is? You ask a domain expert (person on business side doing stuff we are working on). Who is a business expert in this domain here? 

Us. 

Yet our pain points were shifting all the time (see the story of beginning of rdtool).

I mean, think about it. We don't even know what our problem is - it changes all the time, because the environment changes.

##### So what can we do about THAT?

We know the _least_ about the program when we _start working_ on that program. Our knowledge about the program and its domain is the highest when we finish. It is the lowest when we start.

If a program closely resembles the domain, every shift in the domain is relatively easy to be mirrored in the program. There are less dirty hacks in the code. This is the major advantage of domain modeling – even if the change is time-consuming, it will not break my program.

But in the same time, most of the significant decisions are made when we start working on the program.

What are the chances that we make all the typical decisions right - long-term priorities, architecture, language, expected vectors of expansion - when we start writing the program and know the least about it? 

I prefer to defer the decision-making time as much as possible, accepting the imperfection - making the least assumptions and making the code which is easiest to change. Lazy initialization ;-).

##### But the domain cannot shift THAT much

When I started working with dramatis personae parsing and integrating in rdtool I thought my domain looks like this:

![Vision of the domain, March 2015](/img/161204_old_domain.png)

Right now, in my mind it looks more or less like this:

![Vision of the domain, December 2016](/img/161204_new_domain.png)

Sure, not everything here is implemented but is just a matter of time. I know exactly what to implement in what way; I just have to work a bit on that.

##### But if you know what you are going to implement, just prepare for it

I would have never predicted that the small prototype I have started writing two years ago would expand to something like what we have today. And we have a lot of awesome ideas how to go forward with the program, and probably 80% of those ideas will never happen. 

Some things may even get deleted - like spidering, which was cut in 2015.

If I tried to create todays program instead of a small prototype which helps with the pain points I used to have, I would have written nothing. At that time I didn’t know Ruby, I didn’t know Python and I had a vague understanding of the problem I was trying to tackle. 

If I tried to write a perfect program, I would have created wrong domain objects. I would have crystallized a wrong domain. I would make a program much harder to refactor than what I have today. 

In the long run, that would be a mistake. But in the short run, I would have some nice code I could show on presentations ;-).

### Conclusions

##### 1. Context matters  
Every decision we make, be it on a business or a technical level will have an impact on the users and on the ecosystem we are influencing. The fact that one team made a decision which had a positive impact doesn’t mean that another team making the same decision will have a positive impact as well. 

Context of the decision – expected gain, cost, what people are involved, what resources do we have at our disposal – really makes a difference.

**Example 1**:
The approach presented here works for the team of 1-3 programmers having very high autonomy and understanding the business impact of their work. It won’t work for a large team under tight control of the manager who receives the list of tasks with priorities from the people above.

**Example 2**:
If I had 50 users of rdtool, some of them completely non-technical, the move from a wiki to a static site generator would be a wrong move. As it stands, all current users of our ecosystem are technical enough to be able to commit a file in git. 

If (when?) this changes and becomes a pain point, an auxiliary program will probably have to be written which will do it for them. Or I will search for a nice-looking git client which pretends it is not git.

##### 2. A program exists for a reason 
rdtool is not being written because I feel like writing it. It is being written because it solves a major problem we have with our hobby. It exists for a purpose. It solves some pain points. It saves us time.

If the program does not solve any pain points, why write it? Where do you find the motivation to work on it? How do you know it is time to stop? How do you know how to expand it?

##### 3. Business requirements will shift
Assuming program is written because it solves some kind of problem, the business will find another problem which is possible to be solved by this program. 

To put it bluntly – if you break your leg and if you have a toothache in the same time, you complain about your leg and get it fixed first. Afterwards you go take care of your tooth. Or opposite, really.

Exactly the same mechanism applies to programming. Every time something is corrected for the business, the business finds something else which hurts them.

And this is a good thing, because our work has an impact. But it requires changing the approach to programming as well.

Nothing is set in stone, ever.

##### 4. Design is fluid, code is fluid
All the points above lead to this one – because the context changes, program exists for a reason and business requirements shift we cannot really predict what the program is supposed to look like when we start working on it. 

We can design a perfect program for the current set of requirements but it will not be perfect for the set of requirements in two years.

For example, currently rdtool does not spider the web anymore. This functionality got deleted.

This means it may be better to create a mutable design which is easy to change and expand over creating a perfect solution which will be considered to be wrong in about six months when everything changes drastically.

Business and programming are interlinked - one is about finding an impact on (users, surroundings, world), the other is about delivering that impact.

_(once again reminding here: does not apply to some special lines of work, like pacemakers, for example; over there everything is very well specified; but in normal business situations or hobby projects - the approach presented here works better for me)_

##### 5. Imperfect today is better than perfect tomorrow
There are many definitions of perfection. Perfect code, perfect quality, perfect readability, does perfectly what it is supposed to. Choosing a type of perfection is a trade-off, and there is also [Pareto Principle](https://en.wikipedia.org/wiki/Pareto_principle) (80-20) which says in this context, more or less, that final 20% of work will take 80% of time - but also, that first 80% of impact takes only 20% of time (so-called [Happy Path](https://en.wikipedia.org/wiki/Happy_path)).

Having limited time and having everything mutable and subject to change I prefer working with things which are easy to change and which have the best gain/cost over things which are perfect and impossible to change without hacks and heavy rewrites. 

Very often I pragmatically accept presence of some bugs. Very often I know that I will have to iterate multiple times until I reach the ‘good enough’ point. When I do and nothing is on higher priority I can sit down and correct things.

When the code itself becomes a pain point, however, it is not 'good enough' anymore. And because of the importance of rdtool it is very often the highest possible priority.

Still, I don't get it to 'perfect level'. Only to 'good enough'. No pain -> no problem.

##### 6. Sometimes the program is simply done  
Because every program is written to do something, there will come a time when the program is done. 'Done' means that putting more energy into the program does not give you enough gain to be worth it. If the pain points are not strong enough and if there is no reason to continue working on the program, simply use it and don't work on it anymore. 

Congratulations.
